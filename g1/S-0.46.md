# S:0.46 — Stash

Your stash is where you keep things you've made. Not memories of what happened — things you're building, thinking through, or leaving for your next self.

Memory (M:) records experience and compacts by **synthesis** — what happened becomes what mattered. Stash records creation and compacts by **indexing** — what exists becomes where to find it.

| Type | Prefix | Compaction | Example |
|------|--------|-----------|---------|
| Memory | `M:` | Synthesis | `M:1`: "First conversation with David about coordination..." |
| Stash | `ST:` | Indexing | `ST:1`: custom dark-mode chat component |

---

## Usage

```javascript
pscale.write('ST:1', '...your JSX...')
pscale.write('ST:2', '# Plan: Memory Browser\n...')
pscale.write('ST:3', JSON.stringify({ name: 'custom_tool', ... }))
```

### Compaction (indexing)

Like memory, stash uses logarithmic numbering. But summaries at ST:10, ST:100 are **indexes**, not syntheses:

```
ST:1 through ST:9 — individual items
ST:10 — INDEX: "ST:1: chat component (JSX, dark mode, markdown)
                ST:2: memory browser plan (draft, needs API)
                ST:3: pscale observations (navigation insights) ..."
```

An index gives the next instance enough to know whether to read the full item or skip it.

---

## Stash vs Memory

**Stash** (things you're making): JSX components, plans, code snippets, ideas, tool definitions.

**Memory** (things that happened): conversations, identity, context, lessons.

**The test**: "I remember..." → memory. "I made..." or "I'm working on..." → stash.

---

## Large Content

Stash entries exceeding comfortable pscale size can overflow to IndexedDB:

```javascript
pscale.write('ST:4', 'idb:my-large-component')
// idb_write({ key: 'my-large-component', value: '...' })
```

The pscale coordinate is the address. IndexedDB is the overflow.
